[一、设计模式](#一、设计模式)
- [1.1 概念](#11-概念)
- [1.2 多态 ](#12-多态 )
- [1.3 封装 ](#13-封装 )
- [1.4 单例模式](#14-单例模式)
- [1.5 工厂模式](#15-工厂模式)
- [1.6 建造者模式](#14-建造者模式)
- [1.5 工厂模式](#15-工厂模式)

# 一、设计模式

## 1.1 概念
  >在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
  >通俗一点说，设计模式是在某种场合下对某个问题的一种解决方案。

  >在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。熟悉这些模式的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到某种模式作为解决方案。

  >所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”。


## 1.2 多态
>多态背后的思想将“不变的事物”与“可变的事物”分离开来
```js
var makeSound = function (animal) {
    animal.sound();
};
var Duck = function () {}
Duck.prototype.sound = function () {
    console.log('嘎嘎嘎');
};
var Chicken = function () {}
Chicken.prototype.sound = function () {
    console.log('咯咯咯');
};
makeSound(new Duck());
makeSound(new Chicken());
var Dog = function () {}
Dog.prototype.sound = function () {
    console.log('汪汪汪');
};
makeSound(new Dog());
```


## 1.3 封装
>封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。
```js
/** 封装实现, 实现查找一个数组中的复合条件的对象的实现方法* */ 
Array.prototype.find = function (findData) {
  let loaclKeys = [];
  for (let [index, elem] of this.entries()) {
    loaclKeys.push(...Object.keys(elem));
  }
  let argKeys = Object.keys(findData);
  let finalMatchData = [];
  argKeys.forEach(searchKey => {
    if (!loaclKeys.includes(searchKey)) {
      throw "没有符合条件的数据"; //简易判断        
    }
  }) 
  return this.filter((item) => {
    let matchState = []
    for (let i = 0; i < argKeys.length; i++) {
      matchState.push(item[argKeys[i]] === findData[argKeys[i]]);
    }
    return !matchState.includes(false);
  })
}
```


## 1.4单例模式
* 普通单例
>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
```js
var Singleton = function (name) {
  this.name = name;
}
Singleton.prototype.getName = function () {
  alert(this.name);
};
Singleton.getInstance = function (name) { //提供一个访问Singleton类的实例的接口�
  console.log(this.instance);
  if ( !this.instance ){ // 检测是否已经存在这个实例�
    this.instance = new Singleton( name ); //不存在则生成�
  }   
  return this.instance; // 已经存在则直接返回, 确保多次调用只会返回一次实例
};
var a = Singleton.getInstance( 'sven1' );
var b = Singleton.getInstance( 'sven2' );
alert ( a === b ); // true
```

* 透明单例
>用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。 ( 这个所说的透明是指从外观上,看不出普通的类和透明的类之间的区别是啥 )

```js
let CreateUniqDiv = (function () {
  let instance;
  class createDiv {
    constructor(html) {
      if (instance) { //是否已经创造一个实例, 如果已经创造过,则直接返回之前创造的
        return instance;
      }
      this.html=html;
      instance=this;//当第一次运行该函数后, 把生成的示例存储在闭包的数据之中
    }
    init(){
      let div = document.createElement("div");
      div.innerHTML = this.html;
      document.body.appendChild(div);
    }
  }
  return createDiv;
})();
let a = new CreateUniqDiv('sven1'); // 改类的全局访问点, 就是这个函数本身
let b = new CreateUniqDiv('sven2');
alert(a === b); // true
```

* 用代理实现单例模式
>通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类proxySingletonCreateDiv 中。
这样一来，CreateDiv 就变成了一个普通的类，它跟proxySingletonCreateDiv 组合起来可以达到单例模式的效果。

```js
class CreateDiv {
  constructor(html) {
    this.html = html;
    this.init();
  }
  init() {
    let div = document.createElement("div");
    div.innerHTML = this.html;
    document.body.appendChild(div);
  }
}
var ProxySingletonCreateDiv = (function () {
  var instance;
  return function (html) {
    if (!instance) {
      //是否已经创造一个实例, 如果已经创造过,则直接返回之前创造的
      instance = new CreateDiv( html );
      //当第一次运行该函数后, 把生成的示例存储在闭包的数据之中
    }
    return instance;
  }
})();
let c = new ProxySingletonCreateDiv('sven1'); // 改类的全局访问点, 就是这个函数本身
let d = new ProxySingletonCreateDiv('sven2');
alert(c === d); // true
```


* 惰性单例
>惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用
```js
/** 要做到单例的复用性, 
 * 那么我们先把之前实现单例的那些代码中的变与不变的部分拆分开* @param :管理单例* @fn: 执行的业务函数* */
function getSingle(fn) {
  let result = null;
  return function () {
    console.log(this);
    return result || (result = fn.apply(this, arguments));
  }
}
/** 实验性的业务函数* */
let createSingleIframe = getSingle(function () {
  let iframe = document.createElement('iframe');
  document.body.appendChild(iframe);
  return iframe;
});
document.getElementById('loginBtn').onclick = function () {
  let loginLayer = createSingleIframe();
  loginLayer.src = 'http://baidu.com';
};
```

## 1.5 工厂模式
>工厂模式就是使 同一类别 的 类 综合起来，以使接口统一方便调用，同时在修改以及扩展时更加方便。

>利用工厂模式批量制造一系列的相似对象
```js
class Shop {
  constructor(name) {
    return this[name].apply(this, [...arguments]);
  }
  Steak(name, price, time) {
    //内部很是自由, 可以随意使用各种方式
    this.name = name;
    this.price = price;
    this.time = time;
  }
  Grill(args) { //烧烤
    this.price = 20;
    this.time = 15;
  }
  Noodles(args) { //面条
    this.price = 15;
    this.time = 10;
  }
}
//统一方法调用
let a = new Shop("Steak", 90, 30); //老板来份牛排
let b = new Shop("Grill"); //老板来份烧烤
let c = new Shop("Noodles"); //老板来份面条
```


## 1.6 建造者模式
>建造者模式（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

>看名称我们首先想到的就是造房子。建造者模式就像是施工团队，包工头和客户沟通了解了客户的建房需求后，在自己团队内部分发任务，将复杂的建房过程分解成若干小组，各小组分工合作最终得到需求的房子。

```js
//建造房子场景
//建造者 - 施工团队
let Builder = function () {
  //成员01 -- 决定厅室
  function Rooms(member) {
    if (member <= 0) {
      throw new Error("入住人数错误！");
    }
    this.rooms = member >= 4 ? 4 : member;
  }
  //成员02 -- 决定面积
  function FloorSpace(budget) {
    if ((typeof budget !== "number") || Number.isNaN(budget) || (budget < 60)) {
      throw new Error("预算过低或错误！");
    }
    this.budget = budget;
  } //成员03 -- 整体风格
  function Style(style) {
    this.style = style || "常规风格";
  }
  return class {
    //住几人，预算多少(万)，风格
    constructor(member, budget, style) {
      Rooms.call(this, member);
      FloorSpace.call(this, budget);
      Style.call(this, style);
    }
  };
}(); //包工头获取客户需求，然后建造房子
let house1 = new Builder(1, 100, "小清新"); //客户1的需求
let house2 = new Builder(4, 200, "欧美"); //客户2的需求
```
