- [http](#http)
  - [一、http基本原理](#一http基本原理)
    - [1.1 概念](#11-概念)
    - [1.2MIME(多用途因特网邮件扩展)](#12mime多用途因特网邮件扩展)
    - [1.3 网络地址的基本信息](#13-网络地址的基本信息)
  - [二、HTTP请求的事务逻辑](#二http请求的事务逻辑)
    - [2.1 概念](#21-概念)
    - [2.2 HTTP请求的事务逻辑之连接](#22-http请求的事务逻辑之连接)
    - [2.3 TCP/IP的三次握手/四次挥手](#23-tcpip的三次握手四次挥手)
    - [2.4 常见的业务结构组件](#24-常见的业务结构组件)
  - [三、HTTP报文](#三http报文)
    - [3.1 报文流入源端服务器](#31-报文流入源端服务器)
    - [3.1 报文格式详解](#31-报文格式详解)
    - [3.2 报文状态码详解](#32-报文状态码详解)
    - [3.3 报文首部详解](#33-报文首部详解)
    - [3.4 抓包小工具Fiddler](#34-抓包小工具fiddler)
# http
## 一、http基本原理

### 1.1 概念

Web 内容都是存储在Web 服务器上的。Web 服务器所使用的是HTTP 协议，因此经常会被称为HTTP 服务器。这些HTTP 服务器存储了因特网中的数据，如果HTTP 客户端发出请求的话，它们会提供数据。客户端向服务器发送HTTP 请求，服务器会在HTTP 响应中回送所请求的数据，HTTP 客户端(比如浏览器)和HTTP服务器共同构成了万维网的基本组件。

### 1.2MIME(多用途因特网邮件扩展)

MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。

Web 服务器会为所有HTTP 对象数据附加一个MIME 类型当Web浏览器从服务器中取回一个对象时，会去查看相关的MIME 类型，看看它是否知道应该如何处理这个对象。大多数浏览器都可以处理数百种常见的对象类型：显示图片文件、解析并格式化HTML 文件、通过计算机声卡播放音频文件，或者运行外部5 插件软件来处理特殊格式的数据。

Content-type: image/jpeg   image/svg+xml
Content-length: 12984
* Content-type
  * HTML 格式的文本文档由 text/html 类型来标记。
  * 普通的 ASCII 文本文档由 text/plain 类型来标记。
  * JPEG 格式的图片为 image/jpeg 类型。
  * GIF 格式的图片为 image/gif 类型。
  * Apple 的 QuickTime 电影为 video/quicktime 类型。
  * 微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。

### 1.3 网络地址的基本信息

每个Web 服务器资源都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么了。服务器资源名被称为统一资源标识符（Uniform Resource Identifier，URI）。URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。

统一资源定位符（URL）是资源标识符最常见的形式。URL 描述了一台特定服务器上某资源的特定位置。它们可以明确说明如何从一个精确、固定的位置获取资源。

* 大部分URL 都遵循一种标准格式，这种格式包含三个部分。
  * URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这
  部分通常就是HTTP 协议（http://）。
  * 第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com）。
  * 其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）。
  现在，几乎所有的URI 都是URL。
* 大多数URL 方案的URL 语法都建立在这个由9 部分构成的通用格式上：
```html
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
```
  * 方案：访问服务器以获取资源时要使用哪种协议
  * 用户：某些方案访问资源时需要用户名
  * 密码：用户名后面可能需要包含密码，用冒号分隔
  * 主机：资源宿主服务器的主机名或点分IP地址
  * 端口：资源宿主服务器正在监听的端口号，很多方案都有默认端口号（HTTP的默认端口号为80）
  * 路径：服务器上资源的本地名，由一个斜杠将其与前面的URL组件分隔开来，路径组件的语法是与服务器和方案有关的
  * 参数：某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号(;)分隔
  * 查询：某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分隔开来。
  * 片段：一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的。通过字符“#”将其其与URL的其余部分分隔开来

几乎没有哪个URL 中包含了所有这些组件(不同类型的URL包含了里面的几个不同的部分)
URL 最重要的3 个部分是方案（scheme）、主机（host）和路径（path）

* 方案
  * file：方案file表示一台指定主机（通过本地磁盘，网络文件系统或其他一些文件共享系统）上可直接访问的文件。各字段都遵循用户格式。本地主机可以省略主机名。
  ```html
  基本格式：
  file://<host>/<path>
  示例：
  file://OFFICE-FS/policies/c.doc
  ```
  * news：用户来访问一些特定的文章或新闻组。它有一个很独特的性质：news URL自身包含的信息不足以对资源进行定位。
  ```html
  其他格式： 
    news:<newsgroup>
    news:<news-article-id>
  示例：
    news:rec.arts.startrek
  ```
  * telnet：用户访问交互式业务。它表示的并不是对象自身，而是可通过telnet协议访问的交互式应用程序（资源）。
  ```html
  基本格式：
  telnet://<user>:<pasworld>@<host>:<port>/
  示例：
  telnet://slurp:webhound@joes-hardware.com:23/
  ```
  * http：超文本传输协议方案，除了没有用户名和密码之外，与通用的URL格式相符。默认端口80
  ```html
  基本格式：
  http://<host>:<port>/<path>?<query>#<frag>
  示例：
  http://www.joes-hardware.com:80/index.html
  ```
  * https:
  方案https与方案http是一对。唯一的区别在于方案https使用了网景的SSL，SSL为HTTP连接提供了端到端的加密机制。其语法与HTTP的语法相同，默认端口为443
  ```html
  基本格式：
  https://<host>:<port>/<path>?<query>#<frag>
  示例：
  https://www.joes-hardware.com:80/index.html
  ```
  * mailto：Mailto URL指向的是E-mail地址。由于En-mail的行为与其他方案都都有所不同（它并不指向任何可以直接访问的对象），所以mailto URL的格式与标准URL的格式也有所不同。
  ```html
  基本格式：
  mailto:<RFC-822-addr-spec>
  示例：
  mailto:joe@joes-hardware.com
  ```
  * ftp：文件传输协议URL可以用来从FTP服务器上下载或身其上载文件，并获取FTP服务器上的目录结构内容的列表。在Web和URL出现之前FTP就已经存在了。Web应用程序将FTP作为一种数据访问方案使用。URL语法遵循下列通用格式。
  ```html
  基本格式：
  ftp://<user>:<password>@<host>:<port>/<path>;<params>
  示例：
  ftp://anonymous:joe%40joes@prep.ai.mit.edu:21/pub/gnu/
  ```
  * rtsp,rtspu：RTSP URL是可以通过实时流传输协议（Real Time Streaming Protocol）解析的音/视频媒体资源的标识符。方案rtspu中的u表示UDP协议来获取资源的。
  ```html
  基本格式：
  rtsp://<user>:<password>@<host>:<port>/<path>
  示例：rtsp://www.joes-hardware.com:554/interview/cto_video
  ```

## 二、HTTP请求的事务逻辑

### 2.1 概念
一个HTTP 事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP 报文（HTTP message）的格式化数据块进行的

* HTTP 报文包括以下三个部分。
  * 起始行
```
报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。
```
  * 首部字段
```
起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。
```
  * 主体
```
空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。
```

### 2.2 HTTP请求的事务逻辑之连接

HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节；它把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。只要建立了TCP 连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了。

* TCP 提供了：
  * 无差错的数据传输；
  * 按序传输（数据总是会按照发送的顺序到达）；
  * 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）

用网络术语来说，HTTP 协议位于TCP 的上层。HTTP 使用TCP 来传输其报文数据。

* HTTP——————应用层
* TCP ——————传输层
* IP  ——————网络层
* 网络特有的链路接口——————数据链路层
* 物理网络硬件——————物理层

在HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条TCP/IP 连接

* 步骤如下：
  * (a) 浏览器从URL 中解析出服务器的主机名；
  * (b) 浏览器将服务器的主机名转换成服务器的IP 地址；
  * (c) 浏览器将端口号（如果有的话）从URL 中解析出来；
  * (d) 浏览器建立一条与Web 服务器的TCP 连接；
  * (e) 浏览器向服务器发送一条HTTP 请求报文；
  * (f) 服务器向浏览器回送一条HTTP 响应报文；
  * (g) 关闭连接，浏览器显示文档。

### 2.3 TCP/IP的三次握手/四次挥手

>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

* 第一次握手：客户端向服务端发送网络包, 当服务端接受到后就可以得知:客户端可以正常的发送信息,以及服务端可以正常的接受信息
* 第二次握手：服务端向客户端发送网络包, 当客户端接受到后就可以得知:服务端可以正常接受信息和发送信息, 并且自己是可以正常的发送和接受信息
* 第三次握手：客户端向服务端发送网络包, 当服务端接受到后就可以得知:客户端的发送和接受能力正常,自己的发送和接受能力也正常

>当客户端与服务器端关闭一个链接通道时,同样需要双方的确认才行, 这个确认的过程需要四个步骤. 与建立连接只能是客户端向服务端发送不同, 关闭链接可以有任意一方发起
* 第一次挥手：发起方发送 FIN报文，代表断开连接
* 第二次挥手：接收方响应 ACK(确认字符) 报文，并在自己发送完未处理的报文后发送 FIN 报文
* 第三次挥手：发起方接收 ACK 报文后等待接收方的 FIN 报文，收到后发送 ACK 报文，自己进入 TIME_WAIT 状态，等待 2MSL(MSL是最大的报文存活时间,一般是30s,60s或是120s,主要是怕接收方没有接受到ACK报文) 后关闭连接
* 第四次挥手：接收方收到 ACK 报文，关闭连接


### 2.4 常见的业务结构组件

* 代理位于客户端和服务器之间，接收所有客户端的HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。最常见的有一些绿坝(青少年网页内容过滤系统)或是VPN
* 代理位于客户端和服务器之间，接收所有客户端的HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。最常见的有一些绿坝(青少年网页内容过滤系统)或是VPN
* 网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。
  * 网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。
* 隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发(只负责转发数据但是不管转发的是啥)的HTTP 应用程序。HTTP 隧道通常用来在一条或多条HTTP 连接上转发非HTTP 数据，转发时不会窥探数据。

## 三、HTTP报文
### 3.1 报文流入源端服务器

<<<<<<< Updated upstream
HTTP 报文是在HTTP 应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。

HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向。报文流入源端服务器，工作完成之后，会流回用户的Agent 代理中

HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动。所有报文的发送者都在接收者的上游（upstream）

### 3.1 报文格式详解

所有的HTTP 报文都可以分为两类： 请求报文（request message） 和响应报文（response message）。请求报文会向Web 服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同
```html
<!--这是请求报文的格式：-->
<method> <request-URL> <version>
<headers>
<entity-body>
<!--这是响应报文的格式（注意，只有起始行的语法有所不同）：-->
<version> <status> <reason-phrase>
<headers>
<entity-body>
```
所有的HTTP 报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么。响应报文的起始行说明发生了什么。

* 下面是对各部分的简要描述。
  * 方法（method）
客户端希望服务器对资源执行的动作。是一个单独的词，比如GET、HEAD 或POST。
    * POST: 向服务器发送数据如表单
    * PUT: 将请求的主体部分存储在服务器上
    * GET: 从服务器上获取一份文档
    * DELETE: 从服务器上删除一份文档
    * HEAD: 只从服务器上获取文档的首部
    * OPTIONS: 决定可以在服务器上执行哪些方法
    * TRACE: 对可能经过代理服务器传送到服务器上的报文进行追踪
  * 请求URL（request-URL）
命名了所请求资源，或者URL 路径组件的完整URL。如果直接与服务器进行对话，只要URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL 的主机/ 端口。
  * 版本（version）
报文所使用的HTTP 版本，其格式看起来是这样的：HTTP/<major>.<minor>其中主要版本号（major）和次要版本号（minor）都是整数。
  * 状态码（status-code）
这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。
  * 原因短语（reason-phrase）
数字状态码的可读版本，包含行终止序列之前的所有文本。本章稍后提供了HTTP 规范定义的所有状态码的原因短语示例。原因短语只对人类有意义，因此，比如说，尽管响应行HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短语的含义不同，但同样都会被当作成功指示处理
  * 首部（header）
可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP 版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部
  * 实体的主体部分(entity-body)
实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF 结束

### 3.2 报文状态码详解

可以通过三位数字代码对不同状态码进行分类：
* 200-299 之间的状态码表示成功
* 300-399 之间的状态码表示资源已经被移走了
* 400-499 之间的状态码表示客户端的请求出错了
* 500-599 之间的代码表示服务器出错了
```
200: "服务器成功返回请求的数据。",
201: "新建或修改数据成功。",
202: "一个请求已经进入后台排队（异步任务）。",
204: "删除数据成功。",
400: "发出的请求有错误，服务器没有进行新建或修改数据的操作。",
401: "用户没有权限（令牌、用户名、密码错误）。",
403: "用户得到授权，但是访问是被禁止的。",
404: "发出的请求针对的是不存在的记录，服务器没有进行操作。",
406: "请求的格式不可得。",
410: "请求的资源被永久删除，且不会再得到的。",
422: "当创建一个对象时，发生一个验证错误。",
500: "服务器发生错误，请检查服务器。",
502: "网关错误。",
503: "服务不可用，服务器暂时过载或维护。",
504: "网关超时。
```
### 3.3 报文首部详解

HTTP首部可以分为以下几类：
* 通用首部：即可以出现在请求报文中又可以出现在响应报文中。
* 请求首部：提供更多有关请求的信息。
* 响应首部：提供更多有关响应的信息。
* 实体首部：描述主体的长度和内容，或都资源自身。
* 扩展首部：规范中没有定义的新首部。每个HTTP首部都有一种简单的语法：名字后面跟着冒号，然后跟上可选的空格，再跟上字段值，最后是一个CRLF

* 通用首部：不论报文是何类型，都为其提供一些有用信息
  * Connection：允许客户端和服务器指定与请求/响应连接有关的选项。
  * Date‘：提供日期和时间标志，说明报文是什么时间创建的。
  * MIME-Version：给出发送端使用的MIME版本。
  * Trailer：如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合。
  * Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。
  * Update：给出了发送端可能想要“升级”使用的新版本或协议。
  * Via：显示了报文经过的中间节点（代理、网关）。
* 请求首部：只在请求报文中有意义的首部
  * Client-IP：提供了运行客户端的机器的IP地址
  * From：提供了客户端用户的E-mail地址
  * host：给出了接收请求的服务器的主机名和端口号
  * Referer：提供了包含当前请求URI的文档的URL
  * UA-Color：提供了与客户端显示器的显示颜色有关的信息
  * UA-cpu：提供了与客户端CPU的类型或制造商
  * UA-Disp：提供了与客户端显示器（屏幕）能力有送的信息
  * UA-os：给出了运行在客户端机器上的操作系统名称及版本
  * UA-Pixels：提供了客户端显示器的像素信息
  * User-Agent：将发起请求的应用程序名称告知服务器
  * Accept首部：首部为客户端提供了一种将其喜好和能力告知服务器的方式
    * Accept：告诉服务器能够发送哪些媒体类型
    * Accept-Charset：告诉服务器能够发送哪些字符集
    * Accept-Encoding：告诉服务器能够发送哪些编码方式
    * Accept-Language：告诉服务器能够发送哪些语言
    * TE：告诉服务器可以使用哪些扩展传输编码
  * 有时客户端希望为请求加上某些限制:
    * Expect：允许客户端列出某请求所要求的服务器行为
    * If-Match：如果实体标记与文档当前的实体票房相匹配，就获取这份文档
    * If-Modified-Since：除非在某个指定的日期之后资源被个性过，否则就限制这个请求
    * If-None-Match：如果提供的实体标记与当前文档的实体票房不相符，就获取文档
    * If-Range：允许文档的某个范围进行条件请求
    * If-Unmodified-Since：除非在某个指定日期之后资源没有被修改过，否则就限制这个请求
    *  Range：如果服务器支持范围请求，就请求资源的指定范围
    *  Authorization：包含了客户端提供给服务器，以便对其自身进行认证的数据
    *  Cookie：客户端用它向服务器传送一个令牌--它并不是真正的安全首部，但确实隐含了安全功能。
    *  Cookie2：用来说明请求端支持的cookie版本
* 响应首部：响应首部提供的信息有助于客户端处理响应，并在将来发起更好的请求
  * Age：（从最初创建开始）响应持续时间
  * Public：服务器为其资源支持的请求方法列表
  * Retry-After：如果资源不可用的话，在此日期或时间重试
  * Server：服务器应用程序软件的名称和版本
  * Title：对HTML文档来说，就是HTML文档的源端给出的标题
  * Warning：比原因短语中更详细一些的警告报文
* 内容首部：
  * Content-Base：解析主体中的相对URL时使用的基础URL
  * Content-Encoding：对主体执行的任意编码方式
  * Content-Language：理解主体时最适宜使用的自然语言
  * Content-Length：主体的长度或尺寸
  * Content-Location：资源实际所处的位置
  * Content-MD5：主体的MD5校验和
  * Content-Range：在整个资源中此实体表示的字节范围
  * Content-Type：这个主体的对象类型

### 3.4 抓包小工具Fiddler
=======

## 二、TCP连接

### 2.1 概念

### 2.2 TCP连接的数据包
* 输入URL后请求过程
  * 1、浏览器解析出主机名
  * 2、浏览器查询这个主机名的IP地址（DNS）
  * 3、浏览器获取端口号（80）
  * 4、浏览器发起到202.43.78.3:80的连接
  * 5、浏览器向服务发送一条HTTP GET报文
  * 6、浏览器从服务器读取HTTP响应报文
  * 7、浏览器关闭连接

>HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在IP 分组中，通过因特网进行传输。

>一个包1400字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送7100多个包。

>发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。

>第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101(编号加长度)。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。

### 2.3 TCP连接的性能分析

* HTTP事务的时延有以下几种主要原因：
  * 客户端需要根据域名来分析IP和端口号,如果目标网站属于小众网站且使用解析服务很差,那么这个DNS查询会消耗不少时间。
  * 接下来，客户端会向服务器发送一条TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的TCP 连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP 事务的话，这个值会快速地叠加上去。
  * 一旦连接建立起来了，客户端就会通过新建立的TCP 管道来发送HTTP 请求。数据到达时，Web 服务器会从TCP 连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。
  * 然后，Web 服务器会回送HTTP 响应，这也需要花费时间。

  这些TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。

* TCP连接的延迟和延迟确认
  * TCP连接的延迟: 通常HTTP 事务都不会交换太多数据，此时，SYN/SYN+ACK 握手会产生一个可测量的时延.小的HTTP 事务可能会在TCP 建立上花费50%，或更多的时间
  * 由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以TCP 实现了自己的确认机制来确保数据的成功传输。
  * 每个TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。为了保证减少不必要的检查和错误的检测结果,TCP会使用一个延迟确认算法, 会将一个确认信息在一个窗口时间(一般是100~200ms)外再进行发送

* HTTP事务的慢启动
  * TCP 数据传输的性能还取决于TCP 连接的使用期（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP 慢启动（slow start），用于防止因特网的突然过载和拥塞。

* TCP连接的串行事务处理时延
  * 如果只对连接进行简单的管理，TCP 的性能时延可能会叠加起来。比如，假设有一个包含了3 个嵌入图片的Web 页面。浏览器需要发起4 个HTTP 事务来显示此页面：1 个用于顶层的HTML 页面，3 个用于嵌入的图片。如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来

* TCP连接的并行连接
  * 并行连接不一定更快,但是一般上看去会感觉快一些。
  * HTTP 允许客户端打开多条连接，并行地执行多个HTTP 事务。
  * 包含嵌入对象的组合页面(比如多个iframe或是内部多个外联文件等), 如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。

* TCP连接的持久连接
  * Web 客户端经常会打开到同一个站点的连接。比如，一个Web 页面上的大部分内嵌图片通常都来自同一个Web 站点，而且相当一部分指向其他对象的超链通常都指向同一个站点。因此，初始化了对某服务器HTTP 请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求（比如，获取在线图片）。这种性质被称为站点局部性（site locality）。
  * 因此，HTTP/1.1（以及HTTP/1.0 的各种增强版本） 允许HTTP 设备在事务处理结束之后将TCP 连接保持在打开状态，以便为未来的HTTP 请求重用现存的连接。在事务处理结束之后仍然保持在打开状态的TCP 连接被称为持久连接。非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。
  * 重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。

* TCP连接的持久连接和并行连接的缺陷
  * 并行连接可以提高复合页面的传输速度。但并行连接也有一些缺点：1、每个事务都会打开 / 关闭一条新的连接，会耗费时间和带宽。2、由于 TCP 慢启动特性的存在，每条新连接的性能都会有所降低。3、可打开的并行连接数量实际上是有限的。
  * 持久连接有一些比并行连接更好的地方。持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。但是，管理持久连接时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。
  * 持久连接与并行连接配合使用可能是最高效的方式。现在，很多Web 应用程序都会打开少量的并行连接，其中的每一个都是持久连接。

* TCP连接的持久连接的实现方式
  * 比较老的HTTP/1.0+的“keep-alive”连接
    * 实现HTTP/1.0 keep-alive 连接的客户端可以通过包含Connection: Keep-Alive首部请求将一条连接保持在打开状态。如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有Connection: Keep-Alive 首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。
  * 现代的HTTP/1.1“persistent”连接。
    * 与HTTP/1.0+ 的keep-alive 连接不同，HTTP/1.1 持久连接在默认情况下是激活. 除非特别指明，否则HTTP/1.1 假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显式地添加一个Connection:close 首部。
    * 这是与以前的HTTP 协议版本很重要的区别，在以前的版本中，keepalive连接要么是可选的，要么根本就不支持。
    * HTTP/1.1 逐渐停止了对keep-alive 连接的支持，用一种名为持久连接（persistent-connection）的改进型设计取代了它。持久连接的目的与keep-alive 连接的目的相同，但工作机制更优一些。

* TCP连接的管道连接
  >管道化连接: 在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。
  * 对管道化连接有几条限制。
    * 如果 HTTP 客户端无法确认连接是持久的，就不应该使用管道
    * 必须按照与请求相同的顺序回送 HTTP 响应。HTTP 报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了
    * HTTP 客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了10 条请求，服务器可能在只处理了5 条请求之后关闭连接。剩下的5 条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求。
    * HTTP 客户端不应该用管道化的方式发送会产生副作用的请求（比如 POST）。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试POST 这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。

### 2.4 TCP连接的关闭

  >TCP 连接是双向的。TCP 连接的每一端都有一个输入队列和一个输出队列，用于数据的读或写。放入一端输出队列中的数据最终会出现在另一端的输入队列中。

  >应用程序可以关闭TCP 输入和输出信道中的任意一个，或者将两者都关闭了。套接字调用close() 会将TCP 连接的输入和输出信道都关闭了。这被称作“完全关闭” 。还可以用套接字调用shutdown() 单独关闭输入或输出信道。这被称为“半关闭”
  
  >关闭连接的输出信道总是很安全的,关闭连接的输入信道比较危险，除非你知道另一端不打算再发送其他数据了

## 三、服务器

### 3.1 概念

* 实际的Web服务器会做些什么?

  * 1、建立连接——接受一个客户端连接，或者如果不希望与这个客户端建立连接，就将其关闭。
  * 2、接收请求——从网络中读取一条HTTP 请求报文。
  * 3、处理请求——对请求报文进行解释，并采取行动。
  * 4、访问资源——访问报文中指定的资源。
  * 5、构建响应——创建带有正确首部的HTTP 响应报文。
  * 6、发送响应——将响应回送给客户端。
  * 7、记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中。

### 3.2 服务器代理

>Web 代理（proxy）服务器是网络的中间实体。代理位于客户端和服务器之间，扮演“中间人”的角色，在各端点之间来回传送HTTP 报文。

>简单来说:
* 正向代理,隐藏真实客户端:
  * 
* 反向代理,隐藏真实服务器:
  * 假扮Web 服务器被称为替代物（surrogate）或反向代理（reverse proxy）的代理接收发给Web 服务器的真实请求，但与Web 服务器不同的是，它们可以发起与其他服务器的通信，以便按需定位所请求的内容。

### 3.3 服务器缓存概念

>有很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输。这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重Web 服务器的负载。有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/ 流出原始服务器的、被浪费掉了的重复流量。

>缓存(缓存不仅仅是本机自身的缓存, 还有缓存服务器一说)可以解决的常见问题:
  * 带宽瓶颈
  * 瞬间拥塞
  * 距离时延(超远距离访问, 比如:中国访问美国的网站, 需要计算光速)

>可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存命中（cache hit），其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存未命中（cache miss）

## 四、web爬虫的基本原理
### 4.1 概念
>Web 机器人是能够在无需人类干预的情况下自动进行一系列Web 事务处理的软件程序
很多机器人会从一个Web 站点逛到另一个Web 站点，获取内容，跟踪超链，并对它们找到的数据进行处理。根据这些机器人自动探查Web 站点的方式，人们为它们起了一些各具特色的名字，比如“爬虫”、“蜘蛛”、“蠕虫”以及“机器人”等

>Web 爬虫是一种机器人，它们会递归地对各种信息性Web 站点进行遍历，获取第一个Web 页面，然后获取那个页面指向的所有Web 页面，然后是那些页面指向的所有Web 页面，依此类推。递归地追踪这些Web 链接的机器人会沿着HTML 超链创建的网络“爬行”，所以将其称为爬虫（crawler）或蜘蛛（spider）。

>爬虫开始访问的URL 初始集合被称作根集（root set）
上图所示的扒取逻辑中,只要有A,G,S就可以扒取所有的页面

### 4.2 web爬虫的基本原理之避免环路
机器人在Web 上爬行时，要特别小心不要陷入循环，或环路（cycle）之中.机器人必须知道它们到过何处，以避免环路的出现。环路会造成机器人陷阱，这些陷阱会暂停或减缓机器人的爬行进程。
* 环路造成的不利影响有:
  * 将时间消耗与无限获取相同的页面上了
  * 每次循环的访问也是访问, 要是爬虫与服务器的连接良好, 那么循环访问就犹如是DOS攻击了
  * 爬取大量重复页面被称为dups, 这时的爬虫程序会被重复的内容所充斥

### 4.3 web爬虫的基本原理之如何记录访问历史
在前面的章节咱们讲到, 为了保证不陷入环路我们必须得记录访问的历史, 但是这个记录很是麻烦, 问题在于两个方面:
  * 链接的数目极为庞大, 现如今的web页面数以百亿计, 每次要在这么庞大的链接库里面查询是否已经访问, 那得需要非常优秀的搜索算法, 否则匹配一次就直接gg了
  * 数据的体积庞大, 我们简单算一下, 假设一个url平均是40字节, 那么仅仅100亿个url, 那么体积就是400gb!!!, 这么大的数据为了保证快速读取一般会加载到内存中, 这对服务器的配置消耗极大

* 为解决这些问题, 我们一般会用到以下一些有用的技术
  * 树和散列表
  * 有损的存在位图
  * 检查点(讲已访问的URL保存在硬盘)
  * 分类派遣机器人

## 五、客户端识别和cookie

### 5.1 客户端识别的目的与手段
* 为什么要进行客户端识别, 以淘宝为例:
  * 1、个性化的问候
  * 2、有的放矢的推荐
  * 3、管理信息的存档
  * 4、记录会话
* 可以实现客户端识别的方式有很多, 比如:
  * 1、承载用户身份信息的 HTTP 首部
  * 2、客户端 IP 地址跟踪，通过用户的 IP 地址对其进行识别
  * 3、用户登录，用认证方式来识别用户(配置首部的Authorization)
  * 4、胖 URL，一种在 URL 中嵌入识别信息的技术
  * 5、cookie

### 5.1 cookie
>可以笼统地将cookie 分为两类： 会话cookie 和持久cookie。会话cookie 是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie 就被删除了。持久cookie 的生存时间更长一些；它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie 维护某个用户会周期性访问的站点的配置文件或登录名。

>会话cookie 和持久cookie 之间唯一的区别就是它们的过期时间。

>用户首次访问Web 站点时，Web 服务器对用户一无所知Web 服务器希望这个用户会再次回来，所以想给这个用户“拍上”一个独有的cookie，这样以后它就可以识别出这个用户了。cookie 中包含了一个由名字= 值（name=value）这样的信息构成的任意列表，并通过Set-Cookie 或Set-Cookie2 HTTP 响应（扩展）首部将其贴到用户身上去。

>浏览器会记住从服务器返回的Set-Cookie 或Set-Cookie2 首部中的cookie 内容，并将cookie 集存储在浏览器的cookie 数据库中

## 六、服务认证

### 6.1 概念
>HTTP 提供了一个原生的质询/ 响应（challenge/response）框架，简化了对用户的认证过程

>Web 应用程序收到一条HTTP 请求报文时，服务器没有按照请求执行动作，而是以一个“认证质询”进行响应，要求用户提供一些保密信息来说明他是谁，从而对其进行质询。

>用户再次发起请求时，要附上保密证书（用户名和密码）。如果证书不匹配，服务器可以再次质询客户端，或产生一条错误信息。如果证书匹配，就可以正常完成请求了。

### 6.2 服务器认证的步骤
* 上图，用户请求了私人家庭相片 /family/jeff.jpg。
  * 在图 12-2b 中，服务器回送一条 401 Authorization Required，对私人家庭相片进行密码质询，同时回送的还有WWW-Authenticate 首部。这个首部请求对Family 域进行基本认证。
  * 在图 12-2c 中，浏览器收到了 401 质询，弹出对话框，询问 Family 域的用户名和密码。用户输入用户名和密码时， 浏览器会用一个冒号将其连接起来， 编码成“ 经过扰码的”Base-64 表示形式然后将其放在Authorization 首部中回送。
  * 在图 12-2d 中，服务器对用户名和密码进行解码，验证它们的正确性，然后用一条HTTP 200 OK 报文返回所请求的报文。

>WWW-Authenticate质询中包含了一个realm 指令。Web 服务器会将受保护的文档组织成一个安全域（security realm）。每个安全域都可以有不同的授权用户集。

>HTTP 基本认证将（由冒号分隔的）用户名和密码打包在一起，并用Base-64 编码方式对其进行编码

### 6.3 服务器基本认证的安全缺陷

* 基本认证简单便捷，但并不安全。只能用它来防止非恶意用户无意间进行的访问，或将其与SSL 这样的加密技术配合使用。
  * (1) 基本认证会通过网络发送用户名和密码，这些用户名和密码都是以一种很容易解码的形式表示的。如果有动机的第三方用户有可能会去拦截基本认证发送的用户名和密码，就要通过SSL 加密信道发送所有的HTTP 事务，或者使用更安全的认证协议，比如摘要认证。
  * (2) 即使密码是以更难解码的方式加密的，第三方用户仍然可以捕获被修改过的用户名和密码，并将修改过的用户名和密码一次一次地重放给原始服务器，以获得对服务器的访问权。没有什么措施可用来防止这些重放攻击。
  * (3) 即使将基本认证用于一些不太重要的应用程序，比如公司内部网络的访问控制或个性化内容的访问，一些不良习惯也会让它变得很危险。很多用户由于受不了大量密码保护的服务，会在这些服务间使用相同的用户名和密码。比如说从免费的因特网邮件网站捕获明文形式的用户名和密码，然后会发现用同样的用户名和密码还可以访问重要的在线银行网站！
  * (4)假冒服务器进行欺骗, 以得到用户发送的账号和密码,并存储起来以供后期使用

### 6.4 服务器的摘要认证
>摘要认证遵循的箴言是“绝不通过网络发送密码”。客户端不会发送密码，而是会发送一个“指纹”或密码的“摘要”，这是密码的不可逆扰码。客户端和服务器都知道这个密码，因此服务器可以验证所提供的摘要是否与密码相匹配

>摘要是一种单向函数，主要用于将无限的输入值转换为有限的浓缩输出值。常见的摘要函数MD5会将任意长度的字节序列转换为一个128 位的摘要。

>MD5 输出的128 位的摘要通常会被写成32 个十六进制的字符，每个字符表示4 位

## 七、HTTPS

### 7.1 概念

  大部分困难的编码及解码工作都是在SSL 库中完成的，所以Web 客户端和服务器在使用安全HTTP 时无需过多地修改其协议处理逻辑

  HTTP: HTTP应用层-->TCP传输层-->IP网络层-->网络接口-数据链路层

  HTTP: HTTP应用层-->SSL&TLS安全层-->TCP传输层-->IP网络层-->网络接口-数据链路层

* 我们需要一种能够提供下列功能的HTTP 安全技术。
  * 服务器认证（客户端知道它们是在与真正的而不是伪造的服务器通话）。
  * 客户端认证（服务器知道它们是在与真正的而不是伪造的客户端通话）。
  * 完整性（客户端和服务器的数据不会被修改）。
  * 加密（客户端和服务器的对话是私密的，无需担心被窃听）。
  * 效率（一个运行的足够快的算法，以便低端的客户端和服务器使用）。
  * 普适性（基本上所有的客户端和服务器都支持这些协议）。
  * 管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）。
  * 适应性（能够支持当前最知名的安全方法）。
  * 在社会上的可行性（满足社会的政治文化需要）

### 7.2 名词解释
* 关键名词解释
  * 密码：对文本进行编码，使偷窥者无法识别的算法。
  * 密钥：改变密码行为的数字化参数。
  * 对称密钥加密系统：编/ 解码使用相同密钥的算法。
  * 不对称密钥加密系统：编/ 解码使用不同密钥的算法。
  * 公开密钥加密系统：一种能够使数百万计算机便捷地发送机密报文的系统。
  * 数字签名：用来验证报文未被伪造或篡改的校验和。
  * 数字证书：由一个可信的组织验证和签发的识别信息

### 7.2 对称密钥加密技术
>编/ 解码使用相同密钥的算法。对称密钥加密技术的缺点之一就是发送者和接收者在互相对话之前，一定要有一个共享的保密密钥。

>在对称密钥加密技术中，发送端和接收端要共享相同的密钥k 才能进行通信。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，恢复出原始的明文

>可用密钥值的数量取决于密钥中的位数，以及可能的密钥中有多少是有效的。就对称密钥加密技术来说，通常所有的密钥值都是有效的。8 位的密钥只有256 个可能的密钥值， 40 位的密钥可以有2^40 个可能的密钥值（大约是一万亿个密钥），128 位的密钥可以产生大约340 000 000 000 000 000 000 000 000 000 000 000 000 个可能的密钥值。现在一般采用的都是128位的加密

### 7.3 公开密钥加密技术

>公开密钥加密技术没有为每对主机使用单独的加密/ 解密密钥，而是使用了两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文解码。编码密钥是众所周知的（这也是公开密钥加密这个名字的由来），但只有主机才知道私有的解密密钥

### 7.3 数字签名

>数字签名是附加在报文上的特殊加密校验码。使用数字签名有以下两个好处。

>签名可以证明是作者编写了这 条报文。只有作者才会有最机密的私有密钥， 因此，只有作者才能计算出这些校验和。校验和就像来自作者的个人“签名”一样。
签名可以防止报文被篡改。如果有恶意攻击者在报文传输过程中对其进行了修改，校验和就不再匹配了。由于校验和只有作者保密的私有密钥才能产生，所以攻击者无法为篡改了的报文伪造出正确的校验码。

在发送已加密的HTTP 报文之前，客户端和服务器要进行一次SSL 握手，在这个握手过程中，它们要完成以下工作：
  * 交换协议版本号；
  * 选择一个两端都了解的密码；
  * 对两端的身份进行认证；
  * 生成临时的会话密钥，以便加密信道。

### 7.3 数字证书
数字证书中还包含一组信息，所有这些信息都是由一个官方的“证书颁发机构”以数字方式签发的。基本的数字证书中通常包含一些纸质ID 中常见的内容，比如：
  * 对象的名称（人、服务器、组织等）；
  * 过期时间；
  * 证书发布者（由谁为证书担保）；
  * 来自证书发布者的数字签名；

而且，数字证书通常还包括对象的公开密钥，以及对象和所用签名算法的描述性信息。任何人都可以创建一个数字证书，但并不是所有人都能够获得受人尊敬的签发权，从而为证书信息担保，并用其私有密钥签发证书

通过HTTPS 建立了一个安全Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。服务器证书中包含很多字段，其中包括：
  * Web 站点的名称和主机名；
  * Web 站点的公开密钥；
  * 签名颁发机构的名称；
  * 来自签名颁发机构的签名。

>>>>>>> Stashed changes
